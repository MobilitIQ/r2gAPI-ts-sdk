// tslint:disable
/**
 * Ride2Go API
 * Ride2Go Ridesharing API.  You can find out more about     Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).      For this sample, you can use the api key `special-key` to test the authorization     filters.
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * represents a contact of a persona
 * @export
 * @interface ContactPointDto
 */
export interface ContactPointDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof ContactPointDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof ContactPointDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof ContactPointDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof ContactPointDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    description?: string;
    /**
     * email
     * @type {string}
     * @memberof ContactPointDto
     */
    email?: string;
    /**
     * fax
     * @type {string}
     * @memberof ContactPointDto
     */
    faxnumber?: string;
    /**
     * telephone
     * @type {string}
     * @memberof ContactPointDto
     */
    telephone?: string;
}
/**
 * represents a trip demand
 * @export
 * @interface DemandDto
 */
export interface DemandDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof DemandDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof DemandDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof DemandDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof DemandDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof DemandDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof DemandDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof DemandDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof DemandDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof DemandDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof DemandDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof DemandDto
     */
    description?: string;
    /**
     * availability of this trip
     * @type {string}
     * @memberof DemandDto
     */
    availability?: string;
    /**
     * start of the availability
     * @type {string}
     * @memberof DemandDto
     */
    availabilityStarts?: string;
    /**
     * end of the availability
     * @type {string}
     * @memberof DemandDto
     */
    availabilityEnds?: string;
    /**
     * 
     * @type {TripDto}
     * @memberof DemandDto
     */
    subject?: TripDto;
    /**
     * price of the trip
     * @type {number}
     * @memberof DemandDto
     */
    price?: number;
    /**
     * currency of the price
     * @type {string}
     * @memberof DemandDto
     */
    priceCurrency?: string;
    /**
     * 
     * @type {PersonaDto}
     * @memberof DemandDto
     */
    marketActor?: PersonaDto;
}
/**
 * represents a location with its coordinates
 * @export
 * @interface GeoLocation
 */
export interface GeoLocation {
    /**
     * latitude of the location
     * @type {number}
     * @memberof GeoLocation
     */
    latitude?: number;
    /**
     * longitude of the location
     * @type {number}
     * @memberof GeoLocation
     */
    longitude?: number;
}
/**
 * Represents a number range with integer boundaries. Both boundaries are optional and inclusive.
 * @export
 * @interface IntegerRange
 */
export interface IntegerRange {
    /**
     * lower boundary
     * @type {number}
     * @memberof IntegerRange
     */
    from?: number;
    /**
     * upper boundary
     * @type {number}
     * @memberof IntegerRange
     */
    to?: number;
}
/**
 * represents a trip offer
 * @export
 * @interface OfferDto
 */
export interface OfferDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof OfferDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof OfferDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof OfferDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof OfferDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof OfferDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof OfferDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof OfferDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof OfferDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof OfferDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof OfferDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof OfferDto
     */
    description?: string;
    /**
     * availability of this trip
     * @type {string}
     * @memberof OfferDto
     */
    availability?: string;
    /**
     * start of the availability
     * @type {string}
     * @memberof OfferDto
     */
    availabilityStarts?: string;
    /**
     * end of the availability
     * @type {string}
     * @memberof OfferDto
     */
    availabilityEnds?: string;
    /**
     * 
     * @type {TripDto}
     * @memberof OfferDto
     */
    subject?: TripDto;
    /**
     * price of the trip
     * @type {number}
     * @memberof OfferDto
     */
    price?: number;
    /**
     * currency of the price
     * @type {string}
     * @memberof OfferDto
     */
    priceCurrency?: string;
    /**
     * 
     * @type {PersonaDto}
     * @memberof OfferDto
     */
    marketActor?: PersonaDto;
}
/**
 * holds a page
 * @export
 * @interface PageDemandDto
 */
export interface PageDemandDto {
    /**
     * list of the resulting elements
     * @type {Array<DemandDto>}
     * @memberof PageDemandDto
     */
    results?: Array<DemandDto>;
    /**
     * 
     * @type {PageResponse}
     * @memberof PageDemandDto
     */
    page?: PageResponse;
}
/**
 * holds a page
 * @export
 * @interface PageOfferDto
 */
export interface PageOfferDto {
    /**
     * list of the resulting elements
     * @type {Array<OfferDto>}
     * @memberof PageOfferDto
     */
    results?: Array<OfferDto>;
    /**
     * 
     * @type {PageResponse}
     * @memberof PageOfferDto
     */
    page?: PageResponse;
}
/**
 * pagination request
 * @export
 * @interface PageRequest
 */
export interface PageRequest {
    /**
     * size of the page
     * @type {number}
     * @memberof PageRequest
     */
    pageSize?: number;
    /**
     * index of the page (0 based)
     * @type {number}
     * @memberof PageRequest
     */
    page?: number;
    /**
     * this page\'s first element\'s index within the whole dataset
     * @type {number}
     * @memberof PageRequest
     */
    firstIndex?: number;
}
/**
 * holds information about a page
 * @export
 * @interface PageResponse
 */
export interface PageResponse {
    /**
     * size of the page
     * @type {number}
     * @memberof PageResponse
     */
    pageSize?: number;
    /**
     * index of the page (0 based)
     * @type {number}
     * @memberof PageResponse
     */
    page?: number;
    /**
     * number of total hits
     * @type {number}
     * @memberof PageResponse
     */
    totalCount?: number;
    /**
     * this page\'s last element\'s index within the whole dataset
     * @type {number}
     * @memberof PageResponse
     */
    lastIndex?: number;
    /**
     * is this the first of all pages
     * @type {boolean}
     * @memberof PageResponse
     */
    first?: boolean;
    /**
     * is this the last of all pages
     * @type {boolean}
     * @memberof PageResponse
     */
    last?: boolean;
    /**
     * this page\'s first element\'s index within the whole dataset
     * @type {number}
     * @memberof PageResponse
     */
    firstIndex?: number;
}
/**
 * holds a page
 * @export
 * @interface PageTripDto
 */
export interface PageTripDto {
    /**
     * list of the resulting elements
     * @type {Array<TripDto>}
     * @memberof PageTripDto
     */
    results?: Array<TripDto>;
    /**
     * 
     * @type {PageResponse}
     * @memberof PageTripDto
     */
    page?: PageResponse;
}
/**
 * represents a trip participation
 * @export
 * @interface ParticipationDto
 */
export interface ParticipationDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof ParticipationDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof ParticipationDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof ParticipationDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof ParticipationDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    description?: string;
    /**
     * role of the participant in this trip
     * @type {string}
     * @memberof ParticipationDto
     */
    role?: ParticipationDtoRoleEnum;
    /**
     * participation status
     * @type {string}
     * @memberof ParticipationDto
     */
    status?: ParticipationDtoStatusEnum;
    /**
     * 
     * @type {PersonaDto}
     * @memberof ParticipationDto
     */
    participant?: PersonaDto;
}

/**
    * @export
    * @enum {string}
    */
export enum ParticipationDtoRoleEnum {
    DRIVER = 'DRIVER',
    OPERATOR = 'OPERATOR',
    PASSENGER = 'PASSENGER'
}
/**
    * @export
    * @enum {string}
    */
export enum ParticipationDtoStatusEnum {
    ACCEPTED = 'ACCEPTED',
    REQUESTED = 'REQUESTED',
    REJECTED = 'REJECTED'
}

/**
 * Represents a persona. A Persona is a Character or Profile a User chooses to adapt. In most cases this will be a Profile of a Human, however it can also be used as Profile for technical users/machines or Organisations.
 * @export
 * @interface PersonaDto
 */
export interface PersonaDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof PersonaDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof PersonaDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof PersonaDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof PersonaDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof PersonaDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof PersonaDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof PersonaDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof PersonaDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof PersonaDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof PersonaDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof PersonaDto
     */
    description?: string;
    /**
     * additional name of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    additionalName?: string;
    /**
     * femily name of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    familyName?: string;
    /**
     * given name of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    givenName?: string;
    /**
     * gender of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    gender?: PersonaDtoGenderEnum;
    /**
     * contacts of the persona
     * @type {Array<ContactPointDto>}
     * @memberof PersonaDto
     */
    contactPoints?: Array<ContactPointDto>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaDtoGenderEnum {
    MAN = 'MAN',
    WOMAN = 'WOMAN',
    G = 'G'
}

/**
 * searching criteria, including pagination options
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * 
     * @type {PageRequest}
     * @memberof Search
     */
    page?: PageRequest;
    /**
     * what kind of trips to look for
     * @type {Array<string>}
     * @memberof Search
     */
    tripTypes?: Array<SearchTripTypesEnum>;
    /**
     * 
     * @type {SearchRadius}
     * @memberof Search
     */
    startPoint?: SearchRadius;
    /**
     * 
     * @type {SearchRadius}
     * @memberof Search
     */
    endPoint?: SearchRadius;
    /**
     * 
     * @type {TimeRange}
     * @memberof Search
     */
    departure?: TimeRange;
    /**
     * 
     * @type {TimeRange}
     * @memberof Search
     */
    arrival?: TimeRange;
    /**
     * on which days should the trip reoccur
     * @type {Array<string>}
     * @memberof Search
     */
    reoccurDays?: Array<SearchReoccurDaysEnum>;
    /**
     * is smoking allowed (irrelevant by default)
     * @type {string}
     * @memberof Search
     */
    smoking?: SearchSmokingEnum;
    /**
     * are animals allowed (irrelevant by default)
     * @type {string}
     * @memberof Search
     */
    animals?: SearchAnimalsEnum;
    /**
     * types of transport
     * @type {Array<string>}
     * @memberof Search
     */
    transportTypes?: Array<SearchTransportTypesEnum>;
    /**
     * size of allowed baggage
     * @type {string}
     * @memberof Search
     */
    baggage?: SearchBaggageEnum;
    /**
     * desired gender of the driver (irrelevant by default)
     * @type {string}
     * @memberof Search
     */
    gender?: SearchGenderEnum;
    /**
     * organization associatons
     * @type {Array<string>}
     * @memberof Search
     */
    organizations?: Array<SearchOrganizationsEnum>;
    /**
     * start of the availability of the trip
     * @type {string}
     * @memberof Search
     */
    availabilityStarts?: string;
    /**
     * end of the availability of the trip
     * @type {string}
     * @memberof Search
     */
    availabilityEnds?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SearchTripTypesEnum {
    OFFER = 'OFFER',
    SEARCH = 'SEARCH'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchReoccurDaysEnum {
    MONDAY = 'MONDAY',
    TUESDAY = 'TUESDAY',
    WEDNESDAY = 'WEDNESDAY',
    THURSDAY = 'THURSDAY',
    FRIDAY = 'FRIDAY',
    SATURDAY = 'SATURDAY',
    SUNDAY = 'SUNDAY'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchSmokingEnum {
    YES = 'YES',
    NO = 'NO',
    ASK = 'ASK',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchAnimalsEnum {
    YES = 'YES',
    NO = 'NO',
    ASK = 'ASK',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchTransportTypesEnum {
    CAR = 'CAR',
    PLANE = 'PLANE',
    BOAT = 'BOAT',
    TRAIN = 'TRAIN'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchBaggageEnum {
    SMALL = 'SMALL',
    MEDIUM = 'MEDIUM',
    LARGE = 'LARGE',
    HUGE = 'HUGE'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchGenderEnum {
    MAN = 'MAN',
    WOMAN = 'WOMAN',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchOrganizationsEnum {
    ADAC = 'ADAC',
    ACA = 'ACA',
    ACL = 'ACL',
    TCS = 'TCS',
    TOURING = 'TOURING'
}

/**
 * searching criteria, including pagination options
 * @export
 * @interface SearchDto
 */
export interface SearchDto {
    /**
     * 
     * @type {PageRequest}
     * @memberof SearchDto
     */
    page?: PageRequest;
    /**
     * what kind of trips to look for
     * @type {Array<string>}
     * @memberof SearchDto
     */
    tripTypes?: Array<SearchDtoTripTypesEnum>;
    /**
     * 
     * @type {SearchRadius}
     * @memberof SearchDto
     */
    startPoint?: SearchRadius;
    /**
     * 
     * @type {SearchRadius}
     * @memberof SearchDto
     */
    endPoint?: SearchRadius;
    /**
     * 
     * @type {TimeRangeDto}
     * @memberof SearchDto
     */
    departure?: TimeRangeDto;
    /**
     * 
     * @type {TimeRangeDto}
     * @memberof SearchDto
     */
    arrival?: TimeRangeDto;
    /**
     * on which days should the trip reoccur
     * @type {Array<string>}
     * @memberof SearchDto
     */
    reoccurDays?: Array<SearchDtoReoccurDaysEnum>;
    /**
     * is smoking allowed (irrelevant by default)
     * @type {string}
     * @memberof SearchDto
     */
    smoking?: SearchDtoSmokingEnum;
    /**
     * are animals allowed (irrelevant by default)
     * @type {string}
     * @memberof SearchDto
     */
    animals?: SearchDtoAnimalsEnum;
    /**
     * types of transport
     * @type {Array<string>}
     * @memberof SearchDto
     */
    transportTypes?: Array<SearchDtoTransportTypesEnum>;
    /**
     * size of allowed baggage
     * @type {string}
     * @memberof SearchDto
     */
    baggage?: SearchDtoBaggageEnum;
    /**
     * desired gender of the driver (irrelevant by default)
     * @type {string}
     * @memberof SearchDto
     */
    gender?: SearchDtoGenderEnum;
    /**
     * organization associatons
     * @type {Array<string>}
     * @memberof SearchDto
     */
    organizations?: Array<SearchDtoOrganizationsEnum>;
    /**
     * start of the availability of the trip
     * @type {string}
     * @memberof SearchDto
     */
    availabilityStarts?: string;
    /**
     * end of the availability of the trip
     * @type {string}
     * @memberof SearchDto
     */
    availabilityEnds?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SearchDtoTripTypesEnum {
    OFFER = 'OFFER',
    SEARCH = 'SEARCH'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoReoccurDaysEnum {
    MONDAY = 'MONDAY',
    TUESDAY = 'TUESDAY',
    WEDNESDAY = 'WEDNESDAY',
    THURSDAY = 'THURSDAY',
    FRIDAY = 'FRIDAY',
    SATURDAY = 'SATURDAY',
    SUNDAY = 'SUNDAY'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoSmokingEnum {
    YES = 'YES',
    NO = 'NO',
    ASK = 'ASK',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoAnimalsEnum {
    YES = 'YES',
    NO = 'NO',
    ASK = 'ASK',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoTransportTypesEnum {
    CAR = 'CAR',
    PLANE = 'PLANE',
    BOAT = 'BOAT',
    TRAIN = 'TRAIN'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoBaggageEnum {
    SMALL = 'SMALL',
    MEDIUM = 'MEDIUM',
    LARGE = 'LARGE',
    HUGE = 'HUGE'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoGenderEnum {
    MAN = 'MAN',
    WOMAN = 'WOMAN',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoOrganizationsEnum {
    ADAC = 'ADAC',
    ACA = 'ACA',
    ACL = 'ACL',
    TCS = 'TCS',
    TOURING = 'TOURING'
}

/**
 * represents a circular area
 * @export
 * @interface SearchRadius
 */
export interface SearchRadius {
    /**
     * 
     * @type {GeoLocation}
     * @memberof SearchRadius
     */
    location?: GeoLocation;
    /**
     * area radius in kms
     * @type {number}
     * @memberof SearchRadius
     */
    radius?: number;
}
/**
 * represents a time range
 * @export
 * @interface TimeRange
 */
export interface TimeRange {
    /**
     * mean of the time range
     * @type {string}
     * @memberof TimeRange
     */
    time?: string;
    /**
     * duration between the mean and the ends of the time range
     * @type {number}
     * @memberof TimeRange
     */
    toleranceInDays?: number;
}
/**
 * represents a time range
 * @export
 * @interface TimeRangeDto
 */
export interface TimeRangeDto {
    /**
     * mean of the time range
     * @type {string}
     * @memberof TimeRangeDto
     */
    time?: string;
    /**
     * duration between the mean and the ends of the time range
     * @type {number}
     * @memberof TimeRangeDto
     */
    toleranceInDays?: number;
}
/**
 * represents transport information of a trip
 * @export
 * @interface TransportDto
 */
export interface TransportDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof TransportDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof TransportDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof TransportDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof TransportDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof TransportDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof TransportDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof TransportDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof TransportDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof TransportDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof TransportDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof TransportDto
     */
    description?: string;
    /**
     * type of vehicle
     * @type {string}
     * @memberof TransportDto
     */
    transportType?: TransportDtoTransportTypeEnum;
    /**
     * maximum number of seats (including driver)
     * @type {number}
     * @memberof TransportDto
     */
    seatingCapacity?: number;
    /**
     * how many baggage can be transported
     * @type {string}
     * @memberof TransportDto
     */
    cargoVolume?: TransportDtoCargoVolumeEnum;
    /**
     * 
     * @type {PersonaDto}
     * @memberof TransportDto
     */
    owner?: PersonaDto;
    /**
     * 
     * @type {PersonaDto}
     * @memberof TransportDto
     */
    operator?: PersonaDto;
    /**
     * color of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    color?: string;
    /**
     * manufacturer of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    manufacturer?: string;
    /**
     * model of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    model?: string;
    /**
     * release date of the vehicle model (things like \"fall 2019\" are valid)
     * @type {string}
     * @memberof TransportDto
     */
    modelDate?: string;
    /**
     * registration ID of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    registrationId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TransportDtoTransportTypeEnum {
    CAR = 'CAR',
    PLANE = 'PLANE',
    BOAT = 'BOAT',
    TRAIN = 'TRAIN'
}
/**
    * @export
    * @enum {string}
    */
export enum TransportDtoCargoVolumeEnum {
    SMALL = 'SMALL',
    MEDIUM = 'MEDIUM',
    LARGE = 'LARGE',
    HUGE = 'HUGE'
}

/**
 * represents a trip
 * @export
 * @interface TripDto
 */
export interface TripDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof TripDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof TripDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof TripDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof TripDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof TripDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof TripDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof TripDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof TripDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof TripDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof TripDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof TripDto
     */
    description?: string;
    /**
     * departure time of the trip
     * @type {string}
     * @memberof TripDto
     */
    departureTime?: string;
    /**
     * arrival time of the trip
     * @type {string}
     * @memberof TripDto
     */
    arrivalTime?: string;
    /**
     * 
     * @type {TransportDto}
     * @memberof TripDto
     */
    transport?: TransportDto;
    /**
     * participants
     * @type {Array<ParticipationDto>}
     * @memberof TripDto
     */
    participations?: Array<ParticipationDto>;
    /**
     * the seats currently available to this trip. at most Transport.seatingCapacity -1 (driver)
     * @type {number}
     * @memberof TripDto
     */
    availableSeats?: number;
    /**
     * 
     * @type {OfferDto}
     * @memberof TripDto
     */
    offer?: OfferDto;
    /**
     * 
     * @type {DemandDto}
     * @memberof TripDto
     */
    demand?: DemandDto;
    /**
     * smoking preferences of the trip
     * @type {string}
     * @memberof TripDto
     */
    smoking?: TripDtoSmokingEnum;
    /**
     * animal transport preferences of the trip
     * @type {string}
     * @memberof TripDto
     */
    animals?: TripDtoAnimalsEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TripDtoSmokingEnum {
    YES = 'YES',
    NO = 'NO',
    FLEX = 'FLEX'
}
/**
    * @export
    * @enum {string}
    */
export enum TripDtoAnimalsEnum {
    YES = 'YES',
    NO = 'NO',
    ASK = 'ASK'
}

/**
 * searching criteria, including pagination options
 * @export
 * @interface UserSearch
 */
export interface UserSearch {
    /**
     * 
     * @type {PageRequest}
     * @memberof UserSearch
     */
    page?: PageRequest;
    /**
     * 
     * @type {SearchRadius}
     * @memberof UserSearch
     */
    location?: SearchRadius;
    /**
     * 
     * @type {IntegerRange}
     * @memberof UserSearch
     */
    age?: IntegerRange;
    /**
     * gender of the persona
     * @type {string}
     * @memberof UserSearch
     */
    gender?: UserSearchGenderEnum;
    /**
     * whether the persona should be single
     * @type {string}
     * @memberof UserSearch
     */
    isSingle?: UserSearchIsSingleEnum;
    /**
     * whether the persona should have an avatar picture
     * @type {string}
     * @memberof UserSearch
     */
    hasAvatar?: UserSearchHasAvatarEnum;
    /**
     * whether the persona should be online
     * @type {string}
     * @memberof UserSearch
     */
    isOnline?: UserSearchIsOnlineEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserSearchGenderEnum {
    MAN = 'MAN',
    WOMAN = 'WOMAN',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum UserSearchIsSingleEnum {
    YES = 'YES',
    NO = 'NO',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum UserSearchHasAvatarEnum {
    YES = 'YES',
    NO = 'NO',
    IRRELEVANT = 'IRRELEVANT'
}
/**
    * @export
    * @enum {string}
    */
export enum UserSearchIsOnlineEnum {
    YES = 'YES',
    NO = 'NO',
    IRRELEVANT = 'IRRELEVANT'
}


/**
 * DemandsApi - axios parameter creator
 * @export
 */
export const DemandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(demandDto: DemandDto, options: any = {}): RequestArgs {
            // verify required parameter 'demandDto' is not null or undefined
            if (demandDto === null || demandDto === undefined) {
                throw new RequiredError('demandDto','Required parameter demandDto was null or undefined when calling _delete.');
            }
            const localVarPath = `/demand/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof demandDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(demandDto !== undefined ? demandDto : {}) : (demandDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Deman
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(demandDto: DemandDto, options: any = {}): RequestArgs {
            // verify required parameter 'demandDto' is not null or undefined
            if (demandDto === null || demandDto === undefined) {
                throw new RequiredError('demandDto','Required parameter demandDto was null or undefined when calling create.');
            }
            const localVarPath = `/demand/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof demandDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(demandDto !== undefined ? demandDto : {}) : (demandDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteById.');
            }
            const localVarPath = `/demand/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/demand/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Demand searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(searchDto: SearchDto, options: any = {}): RequestArgs {
            // verify required parameter 'searchDto' is not null or undefined
            if (searchDto === null || searchDto === undefined) {
                throw new RequiredError('searchDto','Required parameter searchDto was null or undefined when calling search.');
            }
            const localVarPath = `/demand/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof searchDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(searchDto !== undefined ? searchDto : {}) : (searchDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(demandDto: DemandDto, options: any = {}): RequestArgs {
            // verify required parameter 'demandDto' is not null or undefined
            if (demandDto === null || demandDto === undefined) {
                throw new RequiredError('demandDto','Required parameter demandDto was null or undefined when calling update.');
            }
            const localVarPath = `/demand/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof demandDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(demandDto !== undefined ? demandDto : {}) : (demandDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemandsApi - functional programming interface
 * @export
 */
export const DemandsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(demandDto: DemandDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration)._delete(demandDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create an Deman
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(demandDto: DemandDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).create(demandDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).deleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).getById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Demand searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(searchDto: SearchDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).search(searchDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(demandDto: DemandDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).update(demandDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DemandsApi - factory interface
 * @export
 */
export const DemandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(demandDto: DemandDto, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration)._delete(demandDto, options)(axios, basePath);
        },
        /**
         * Create an Deman
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(demandDto: DemandDto, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).create(demandDto, options)(axios, basePath);
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).deleteById(id, options)(axios, basePath);
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).getById(id, options)(axios, basePath);
        },
        /**
         * Demand searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(searchDto: SearchDto, options?: any): AxiosPromise<PageDemandDto> {
            return DemandsApiFp(configuration).search(searchDto, options)(axios, basePath);
        },
        /**
         * Update an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(demandDto: DemandDto, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).update(demandDto, options)(axios, basePath);
        },
    };
};

/**
 * DemandsApi - object-oriented interface
 * @export
 * @class DemandsApi
 * @extends {BaseAPI}
 */
export class DemandsApi extends BaseAPI {
    /**
     * Delete an Offer
     * @param {DemandDto} demandDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public _delete(demandDto: DemandDto, options?: any) {
        return DemandsApiFp(this.configuration)._delete(demandDto, options)(this.axios, this.basePath);
    }

    /**
     * Create an Deman
     * @param {DemandDto} demandDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public create(demandDto: DemandDto, options?: any) {
        return DemandsApiFp(this.configuration).create(demandDto, options)(this.axios, this.basePath);
    }

    /**
     * Returns the demand with the given ID
     * @param {string} id ID of the demand to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public deleteById(id: string, options?: any) {
        return DemandsApiFp(this.configuration).deleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the demand with the given ID
     * @param {string} id ID of the demand to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public getById(id: string, options?: any) {
        return DemandsApiFp(this.configuration).getById(id, options)(this.axios, this.basePath);
    }

    /**
     * Demand searching
     * @param {SearchDto} searchDto Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public search(searchDto: SearchDto, options?: any) {
        return DemandsApiFp(this.configuration).search(searchDto, options)(this.axios, this.basePath);
    }

    /**
     * Update an Offer
     * @param {DemandDto} demandDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public update(demandDto: DemandDto, options?: any) {
        return DemandsApiFp(this.configuration).update(demandDto, options)(this.axios, this.basePath);
    }

}


/**
 * OffersApi - axios parameter creator
 * @export
 */
export const OffersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(offerDto: OfferDto, options: any = {}): RequestArgs {
            // verify required parameter 'offerDto' is not null or undefined
            if (offerDto === null || offerDto === undefined) {
                throw new RequiredError('offerDto','Required parameter offerDto was null or undefined when calling create1.');
            }
            const localVarPath = `/offer/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof offerDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(offerDto !== undefined ? offerDto : {}) : (offerDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(offerDto: OfferDto, options: any = {}): RequestArgs {
            // verify required parameter 'offerDto' is not null or undefined
            if (offerDto === null || offerDto === undefined) {
                throw new RequiredError('offerDto','Required parameter offerDto was null or undefined when calling delete1.');
            }
            const localVarPath = `/offer/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof offerDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(offerDto !== undefined ? offerDto : {}) : (offerDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById1(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteById1.');
            }
            const localVarPath = `/offer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the offer with the given ID
         * @param {string} id ID of the offer to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById1.');
            }
            const localVarPath = `/offer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Offer searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchDto: SearchDto, options: any = {}): RequestArgs {
            // verify required parameter 'searchDto' is not null or undefined
            if (searchDto === null || searchDto === undefined) {
                throw new RequiredError('searchDto','Required parameter searchDto was null or undefined when calling search1.');
            }
            const localVarPath = `/offer/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof searchDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(searchDto !== undefined ? searchDto : {}) : (searchDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(offerDto: OfferDto, options: any = {}): RequestArgs {
            // verify required parameter 'offerDto' is not null or undefined
            if (offerDto === null || offerDto === undefined) {
                throw new RequiredError('offerDto','Required parameter offerDto was null or undefined when calling update1.');
            }
            const localVarPath = `/offer/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof offerDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(offerDto !== undefined ? offerDto : {}) : (offerDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OffersApi - functional programming interface
 * @export
 */
export const OffersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(offerDto: OfferDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).create1(offerDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(offerDto: OfferDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).delete1(offerDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById1(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).deleteById1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the offer with the given ID
         * @param {string} id ID of the offer to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).getById1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Offer searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchDto: SearchDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).search1(searchDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(offerDto: OfferDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).update1(offerDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OffersApi - factory interface
 * @export
 */
export const OffersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(offerDto: OfferDto, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).create1(offerDto, options)(axios, basePath);
        },
        /**
         * Delete an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(offerDto: OfferDto, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).delete1(offerDto, options)(axios, basePath);
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById1(id: string, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).deleteById1(id, options)(axios, basePath);
        },
        /**
         * Returns the offer with the given ID
         * @param {string} id ID of the offer to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).getById1(id, options)(axios, basePath);
        },
        /**
         * Offer searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchDto: SearchDto, options?: any): AxiosPromise<PageOfferDto> {
            return OffersApiFp(configuration).search1(searchDto, options)(axios, basePath);
        },
        /**
         * Update an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(offerDto: OfferDto, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).update1(offerDto, options)(axios, basePath);
        },
    };
};

/**
 * OffersApi - object-oriented interface
 * @export
 * @class OffersApi
 * @extends {BaseAPI}
 */
export class OffersApi extends BaseAPI {
    /**
     * Create an Offer
     * @param {OfferDto} offerDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public create1(offerDto: OfferDto, options?: any) {
        return OffersApiFp(this.configuration).create1(offerDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete an Offer
     * @param {OfferDto} offerDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public delete1(offerDto: OfferDto, options?: any) {
        return OffersApiFp(this.configuration).delete1(offerDto, options)(this.axios, this.basePath);
    }

    /**
     * Returns the demand with the given ID
     * @param {string} id ID of the demand to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public deleteById1(id: string, options?: any) {
        return OffersApiFp(this.configuration).deleteById1(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the offer with the given ID
     * @param {string} id ID of the offer to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public getById1(id: string, options?: any) {
        return OffersApiFp(this.configuration).getById1(id, options)(this.axios, this.basePath);
    }

    /**
     * Offer searching
     * @param {SearchDto} searchDto Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public search1(searchDto: SearchDto, options?: any) {
        return OffersApiFp(this.configuration).search1(searchDto, options)(this.axios, this.basePath);
    }

    /**
     * Update an Offer
     * @param {OfferDto} offerDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public update1(offerDto: OfferDto, options?: any) {
        return OffersApiFp(this.configuration).update1(offerDto, options)(this.axios, this.basePath);
    }

}


/**
 * PersonasApi - axios parameter creator
 * @export
 */
export const PersonasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById2.');
            }
            const localVarPath = `/persona/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the contact infos of the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactPoints(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactPoints.');
            }
            const localVarPath = `/persona/{id}/contact`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persona searching
         * @param {UserSearch} userSearch Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(userSearch: UserSearch, options: any = {}): RequestArgs {
            // verify required parameter 'userSearch' is not null or undefined
            if (userSearch === null || userSearch === undefined) {
                throw new RequiredError('userSearch','Required parameter userSearch was null or undefined when calling search2.');
            }
            const localVarPath = `/persona/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userSearch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userSearch !== undefined ? userSearch : {}) : (userSearch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonasApi - functional programming interface
 * @export
 */
export const PersonasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PersonasApiAxiosParamCreator(configuration).getById2(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the contact infos of the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactPoints(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PersonasApiAxiosParamCreator(configuration).getContactPoints(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Persona searching
         * @param {UserSearch} userSearch Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(userSearch: UserSearch, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PersonasApiAxiosParamCreator(configuration).search2(userSearch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonasApi - factory interface
 * @export
 */
export const PersonasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options?: any): AxiosPromise<void> {
            return PersonasApiFp(configuration).getById2(id, options)(axios, basePath);
        },
        /**
         * Returns the contact infos of the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactPoints(id: string, options?: any): AxiosPromise<void> {
            return PersonasApiFp(configuration).getContactPoints(id, options)(axios, basePath);
        },
        /**
         * Persona searching
         * @param {UserSearch} userSearch Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(userSearch: UserSearch, options?: any): AxiosPromise<void> {
            return PersonasApiFp(configuration).search2(userSearch, options)(axios, basePath);
        },
    };
};

/**
 * PersonasApi - object-oriented interface
 * @export
 * @class PersonasApi
 * @extends {BaseAPI}
 */
export class PersonasApi extends BaseAPI {
    /**
     * Returns the persona with the given ID
     * @param {string} id ID of the persona to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getById2(id: string, options?: any) {
        return PersonasApiFp(this.configuration).getById2(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the contact infos of the persona with the given ID
     * @param {string} id ID of the persona to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getContactPoints(id: string, options?: any) {
        return PersonasApiFp(this.configuration).getContactPoints(id, options)(this.axios, this.basePath);
    }

    /**
     * Persona searching
     * @param {UserSearch} userSearch Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public search2(userSearch: UserSearch, options?: any) {
        return PersonasApiFp(this.configuration).search2(userSearch, options)(this.axios, this.basePath);
    }

}


/**
 * TripsApi - axios parameter creator
 * @export
 */
export const TripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the trip with the given ID
         * @param {string} id ID of the trip to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById3.');
            }
            const localVarPath = `/trip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trip searching
         * @param {Search} search Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(search: Search, options: any = {}): RequestArgs {
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling search3.');
            }
            const localVarPath = `/trip/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof search !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(search !== undefined ? search : {}) : (search || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Minimal trip searching
         * @param {Search} search Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMinimal(search: Search, options: any = {}): RequestArgs {
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling searchMinimal.');
            }
            const localVarPath = `/trip/search/minimal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof search !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(search !== undefined ? search : {}) : (search || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TripsApi - functional programming interface
 * @export
 */
export const TripsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the trip with the given ID
         * @param {string} id ID of the trip to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripDto> {
            const localVarAxiosArgs = TripsApiAxiosParamCreator(configuration).getById3(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trip searching
         * @param {Search} search Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(search: Search, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageTripDto> {
            const localVarAxiosArgs = TripsApiAxiosParamCreator(configuration).search3(search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Minimal trip searching
         * @param {Search} search Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMinimal(search: Search, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TripsApiAxiosParamCreator(configuration).searchMinimal(search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TripsApi - factory interface
 * @export
 */
export const TripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the trip with the given ID
         * @param {string} id ID of the trip to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options?: any): AxiosPromise<TripDto> {
            return TripsApiFp(configuration).getById3(id, options)(axios, basePath);
        },
        /**
         * Trip searching
         * @param {Search} search Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(search: Search, options?: any): AxiosPromise<PageTripDto> {
            return TripsApiFp(configuration).search3(search, options)(axios, basePath);
        },
        /**
         * Minimal trip searching
         * @param {Search} search Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMinimal(search: Search, options?: any): AxiosPromise<void> {
            return TripsApiFp(configuration).searchMinimal(search, options)(axios, basePath);
        },
    };
};

/**
 * TripsApi - object-oriented interface
 * @export
 * @class TripsApi
 * @extends {BaseAPI}
 */
export class TripsApi extends BaseAPI {
    /**
     * Returns the trip with the given ID
     * @param {string} id ID of the trip to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public getById3(id: string, options?: any) {
        return TripsApiFp(this.configuration).getById3(id, options)(this.axios, this.basePath);
    }

    /**
     * Trip searching
     * @param {Search} search Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public search3(search: Search, options?: any) {
        return TripsApiFp(this.configuration).search3(search, options)(this.axios, this.basePath);
    }

    /**
     * Minimal trip searching
     * @param {Search} search Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public searchMinimal(search: Search, options?: any) {
        return TripsApiFp(this.configuration).searchMinimal(search, options)(this.axios, this.basePath);
    }

}


