// tslint:disable
/**
 * Ride2Go API
 * Ride2Go Ridesharing API.  You can find out more about     Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).      For this sample, you can use the api key `special-key` to test the authorization     filters.
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ContactPoint
 */
export interface ContactPoint {
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    modified?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContactPoint
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    additionalType?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    faxnumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    telephone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPoint
     */
    mobile?: string;
}
/**
 * represents a contact of a persona
 * @export
 * @interface ContactPointDto
 */
export interface ContactPointDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof ContactPointDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof ContactPointDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof ContactPointDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof ContactPointDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof ContactPointDto
     */
    description?: string;
    /**
     * email
     * @type {string}
     * @memberof ContactPointDto
     */
    email?: string;
    /**
     * fax
     * @type {string}
     * @memberof ContactPointDto
     */
    faxnumber?: string;
    /**
     * telephone
     * @type {string}
     * @memberof ContactPointDto
     */
    telephone?: string;
    /**
     * mobile
     * @type {string}
     * @memberof ContactPointDto
     */
    mobile?: string;
}
/**
 * represents a trip demand
 * @export
 * @interface DemandDto
 */
export interface DemandDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof DemandDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof DemandDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof DemandDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof DemandDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof DemandDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof DemandDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof DemandDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof DemandDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof DemandDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof DemandDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof DemandDto
     */
    description?: string;
    /**
     * availability of this trip
     * @type {string}
     * @memberof DemandDto
     */
    availability?: string;
    /**
     * start of the availability
     * @type {string}
     * @memberof DemandDto
     */
    availabilityStarts?: string;
    /**
     * end of the availability
     * @type {string}
     * @memberof DemandDto
     */
    availabilityEnds?: string;
    /**
     * 
     * @type {TripDto}
     * @memberof DemandDto
     */
    subject?: TripDto;
    /**
     * price of the trip
     * @type {number}
     * @memberof DemandDto
     */
    price?: number;
    /**
     * currency of the price
     * @type {string}
     * @memberof DemandDto
     */
    priceCurrency?: string;
    /**
     * 
     * @type {PersonaDto}
     * @memberof DemandDto
     */
    marketActor?: PersonaDto;
    /**
     * this Market is exclusive to this List of organisations or persons
     * @type {Array<PersonaDto>}
     * @memberof DemandDto
     */
    exclusiveTo?: Array<PersonaDto>;
}
/**
 * Coordinates of this Place, elevation is normalized to 100mNN if unknown
 * @export
 * @interface GeoCoordinatesDto
 */
export interface GeoCoordinatesDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof GeoCoordinatesDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof GeoCoordinatesDto
     */
    description?: string;
    /**
     * The latitude of a location. For example 37.42242 (WGS 84).
     * @type {number}
     * @memberof GeoCoordinatesDto
     */
    latitude?: number;
    /**
     * The longitude of a location. For example -122.08585 (WGS 84).
     * @type {number}
     * @memberof GeoCoordinatesDto
     */
    longitude?: number;
    /**
     * The elevation of a location (WGS 84). 
     * @type {number}
     * @memberof GeoCoordinatesDto
     */
    elevation?: number;
}
/**
 * represents a location with its coordinates
 * @export
 * @interface GeoLocation
 */
export interface GeoLocation {
    /**
     * latitude of the location
     * @type {number}
     * @memberof GeoLocation
     */
    latitude?: number;
    /**
     * longitude of the location
     * @type {number}
     * @memberof GeoLocation
     */
    longitude?: number;
}
/**
 * Represents a number range with integer boundaries. Both boundaries are optional and inclusive.
 * @export
 * @interface IntegerRange
 */
export interface IntegerRange {
    /**
     * lower boundary
     * @type {number}
     * @memberof IntegerRange
     */
    from?: number;
    /**
     * upper boundary
     * @type {number}
     * @memberof IntegerRange
     */
    to?: number;
}
/**
 * represents a trip offer
 * @export
 * @interface OfferDto
 */
export interface OfferDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof OfferDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof OfferDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof OfferDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof OfferDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof OfferDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof OfferDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof OfferDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof OfferDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof OfferDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof OfferDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof OfferDto
     */
    description?: string;
    /**
     * availability of this trip
     * @type {string}
     * @memberof OfferDto
     */
    availability?: string;
    /**
     * start of the availability
     * @type {string}
     * @memberof OfferDto
     */
    availabilityStarts?: string;
    /**
     * end of the availability
     * @type {string}
     * @memberof OfferDto
     */
    availabilityEnds?: string;
    /**
     * 
     * @type {TripDto}
     * @memberof OfferDto
     */
    subject?: TripDto;
    /**
     * price of the trip
     * @type {number}
     * @memberof OfferDto
     */
    price?: number;
    /**
     * currency of the price
     * @type {string}
     * @memberof OfferDto
     */
    priceCurrency?: string;
    /**
     * 
     * @type {PersonaDto}
     * @memberof OfferDto
     */
    marketActor?: PersonaDto;
    /**
     * this Market is exclusive to this List of organisations or persons
     * @type {Array<PersonaDto>}
     * @memberof OfferDto
     */
    exclusiveTo?: Array<PersonaDto>;
}
/**
 * holds a page
 * @export
 * @interface PageDemandDto
 */
export interface PageDemandDto {
    /**
     * list of the resulting elements
     * @type {Array<DemandDto>}
     * @memberof PageDemandDto
     */
    results?: Array<DemandDto>;
    /**
     * 
     * @type {PageResponse}
     * @memberof PageDemandDto
     */
    page?: PageResponse;
}
/**
 * holds a page
 * @export
 * @interface PageOfferDto
 */
export interface PageOfferDto {
    /**
     * list of the resulting elements
     * @type {Array<OfferDto>}
     * @memberof PageOfferDto
     */
    results?: Array<OfferDto>;
    /**
     * 
     * @type {PageResponse}
     * @memberof PageOfferDto
     */
    page?: PageResponse;
}
/**
 * pagination request
 * @export
 * @interface PageRequest
 */
export interface PageRequest {
    /**
     * size of the page
     * @type {number}
     * @memberof PageRequest
     */
    pageSize?: number;
    /**
     * index of the page (0 based)
     * @type {number}
     * @memberof PageRequest
     */
    page?: number;
    /**
     * this page\'s first element\'s index within the whole dataset
     * @type {number}
     * @memberof PageRequest
     */
    firstIndex?: number;
}
/**
 * holds information about a page
 * @export
 * @interface PageResponse
 */
export interface PageResponse {
    /**
     * size of the page
     * @type {number}
     * @memberof PageResponse
     */
    pageSize?: number;
    /**
     * index of the page (0 based)
     * @type {number}
     * @memberof PageResponse
     */
    page?: number;
    /**
     * number of total hits
     * @type {number}
     * @memberof PageResponse
     */
    totalCount?: number;
    /**
     * this page\'s last element\'s index within the whole dataset
     * @type {number}
     * @memberof PageResponse
     */
    lastIndex?: number;
    /**
     * is this the first of all pages
     * @type {boolean}
     * @memberof PageResponse
     */
    first?: boolean;
    /**
     * is this the last of all pages
     * @type {boolean}
     * @memberof PageResponse
     */
    last?: boolean;
    /**
     * this page\'s first element\'s index within the whole dataset
     * @type {number}
     * @memberof PageResponse
     */
    firstIndex?: number;
}
/**
 * holds a page
 * @export
 * @interface PageTripDto
 */
export interface PageTripDto {
    /**
     * list of the resulting elements
     * @type {Array<TripDto>}
     * @memberof PageTripDto
     */
    results?: Array<TripDto>;
    /**
     * 
     * @type {PageResponse}
     * @memberof PageTripDto
     */
    page?: PageResponse;
}
/**
 * represents a trip participation
 * @export
 * @interface ParticipationDto
 */
export interface ParticipationDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof ParticipationDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof ParticipationDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof ParticipationDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof ParticipationDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof ParticipationDto
     */
    description?: string;
    /**
     * role of the participant in this trip
     * @type {string}
     * @memberof ParticipationDto
     */
    role?: ParticipationDtoRoleEnum;
    /**
     * participation status
     * @type {string}
     * @memberof ParticipationDto
     */
    status?: ParticipationDtoStatusEnum;
    /**
     * 
     * @type {PersonaDto}
     * @memberof ParticipationDto
     */
    participant?: PersonaDto;
}

/**
    * @export
    * @enum {string}
    */
export enum ParticipationDtoRoleEnum {
    DRIVER,
    OPERATOR,
    PASSENGER
}
/**
    * @export
    * @enum {string}
    */
export enum ParticipationDtoStatusEnum {
    ACCEPTED,
    REQUESTED,
    REJECTED
}

/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    modified?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Persona
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    additionalType?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    additionalName?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    givenName?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    gender?: PersonaGenderEnum;
    /**
     * 
     * @type {Array<ContactPoint>}
     * @memberof Persona
     */
    contactPoints?: Array<ContactPoint>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaGenderEnum {
    MAN,
    WOMAN,
    G
}

/**
 * Represents a persona. A Persona is a Character or Profile a User chooses to adapt. In most cases this will be a Profile of a Human, however it can also be used as Profile for technical users/machines or Organisations.
 * @export
 * @interface PersonaDto
 */
export interface PersonaDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof PersonaDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof PersonaDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof PersonaDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof PersonaDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof PersonaDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof PersonaDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof PersonaDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof PersonaDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof PersonaDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof PersonaDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof PersonaDto
     */
    description?: string;
    /**
     * additional name of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    additionalName?: string;
    /**
     * femily name of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    familyName?: string;
    /**
     * given name of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    givenName?: string;
    /**
     * gender of the persona
     * @type {string}
     * @memberof PersonaDto
     */
    gender?: PersonaDtoGenderEnum;
    /**
     * contacts of the persona
     * @type {Array<ContactPointDto>}
     * @memberof PersonaDto
     */
    contactPoints?: Array<ContactPointDto>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaDtoGenderEnum {
    MAN,
    WOMAN,
    G
}

/**
 * Arrival Stop of Trip
 * @export
 * @interface PlaceDto
 */
export interface PlaceDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof PlaceDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof PlaceDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof PlaceDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof PlaceDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof PlaceDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof PlaceDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof PlaceDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof PlaceDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof PlaceDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof PlaceDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof PlaceDto
     */
    description?: string;
    /**
     * A single-line Address
     * @type {string}
     * @memberof PlaceDto
     */
    simpleAddress?: string;
    /**
     * 
     * @type {PostalAddressDto}
     * @memberof PlaceDto
     */
    address?: PostalAddressDto;
    /**
     * 
     * @type {GeoCoordinatesDto}
     * @memberof PlaceDto
     */
    geo?: GeoCoordinatesDto;
}
/**
 * An Postal Address of this Place
 * @export
 * @interface PostalAddressDto
 */
export interface PostalAddressDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof PostalAddressDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof PostalAddressDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof PostalAddressDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof PostalAddressDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof PostalAddressDto
     */
    description?: string;
    /**
     * Street and House Number or Flat
     * @type {string}
     * @memberof PostalAddressDto
     */
    streetAddress?: string;
    /**
     * ZIP Code
     * @type {string}
     * @memberof PostalAddressDto
     */
    postalCode?: string;
    /**
     * Name of Country
     * @type {string}
     * @memberof PostalAddressDto
     */
    country?: string;
    /**
     * ISO three-letter Language Code
     * @type {string}
     * @memberof PostalAddressDto
     */
    countryCode?: string;
}
/**
 * A schedule defines a repeating time period used to describe a regularly occurring Event.
 * @export
 * @interface ScheduleDto
 */
export interface ScheduleDto {
    /**
     * Day of Week this Event is scheduled
     * @type {string}
     * @memberof ScheduleDto
     */
    byDay?: ScheduleDtoByDayEnum;
    /**
     * Month of year this Event is scheduled
     * @type {string}
     * @memberof ScheduleDto
     */
    byMonth?: ScheduleDtoByMonthEnum;
    /**
     * Day of Month. Must be between 1 -31
     * @type {number}
     * @memberof ScheduleDto
     */
    byDayOfMonth?: number;
    /**
     * earliest Start Date of Interval
     * @type {string}
     * @memberof ScheduleDto
     */
    startDate?: string;
    /**
     * End Date of Interval
     * @type {string}
     * @memberof ScheduleDto
     */
    endDate?: string;
    /**
     * earliest Start Date of Interval
     * @type {Array<string>}
     * @memberof ScheduleDto
     */
    exceptDates?: Array<string>;
    /**
     * number of repetitions, 0 for neverending
     * @type {number}
     * @memberof ScheduleDto
     */
    repeatCount?: number;
    /**
     * 
     * @type {ScheduleDtoScheduleTimezone}
     * @memberof ScheduleDto
     */
    scheduleTimezone?: ScheduleDtoScheduleTimezone;
}

/**
    * @export
    * @enum {string}
    */
export enum ScheduleDtoByDayEnum {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
/**
    * @export
    * @enum {string}
    */
export enum ScheduleDtoByMonthEnum {
    JANUARY,
    FEBRUARY,
    MARCH,
    APRIL,
    MAY,
    JUNE,
    JULY,
    AUGUST,
    SEPTEMBER,
    OCTOBER,
    NOVEMBER,
    DECEMBER
}

/**
 * timezone of this schedule
 * @export
 * @interface ScheduleDtoScheduleTimezone
 */
export interface ScheduleDtoScheduleTimezone {
    /**
     * 
     * @type {string}
     * @memberof ScheduleDtoScheduleTimezone
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDtoScheduleTimezone
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduleDtoScheduleTimezone
     */
    rawOffset?: number;
    /**
     * 
     * @type {number}
     * @memberof ScheduleDtoScheduleTimezone
     */
    dstsavings?: number;
}
/**
 * searching criteria, including pagination options
 * @export
 * @interface SearchDto
 */
export interface SearchDto {
    /**
     * 
     * @type {PageRequest}
     * @memberof SearchDto
     */
    page?: PageRequest;
    /**
     * what kind of trips to look for
     * @type {Array<string>}
     * @memberof SearchDto
     */
    tripTypes?: Array<SearchDtoTripTypesEnum>;
    /**
     * 
     * @type {SearchRadius}
     * @memberof SearchDto
     */
    startPoint?: SearchRadius;
    /**
     * 
     * @type {SearchRadius}
     * @memberof SearchDto
     */
    endPoint?: SearchRadius;
    /**
     * 
     * @type {TimeRangeDto}
     * @memberof SearchDto
     */
    departure?: TimeRangeDto;
    /**
     * 
     * @type {TimeRangeDto}
     * @memberof SearchDto
     */
    arrival?: TimeRangeDto;
    /**
     * on which days should the trip reoccur
     * @type {Array<string>}
     * @memberof SearchDto
     */
    reoccurDays?: Array<SearchDtoReoccurDaysEnum>;
    /**
     * is smoking allowed (irrelevant by default)
     * @type {string}
     * @memberof SearchDto
     */
    smoking?: SearchDtoSmokingEnum;
    /**
     * are animals allowed (irrelevant by default)
     * @type {string}
     * @memberof SearchDto
     */
    animals?: SearchDtoAnimalsEnum;
    /**
     * types of transport
     * @type {Array<string>}
     * @memberof SearchDto
     */
    transportTypes?: Array<SearchDtoTransportTypesEnum>;
    /**
     * size of allowed baggage
     * @type {string}
     * @memberof SearchDto
     */
    baggage?: SearchDtoBaggageEnum;
    /**
     * desired gender of the driver (irrelevant by default)
     * @type {string}
     * @memberof SearchDto
     */
    gender?: SearchDtoGenderEnum;
    /**
     * organization associatons
     * @type {Array<string>}
     * @memberof SearchDto
     */
    organizations?: Array<SearchDtoOrganizationsEnum>;
    /**
     * start of the availability of the trip
     * @type {string}
     * @memberof SearchDto
     */
    availabilityStarts?: string;
    /**
     * end of the availability of the trip
     * @type {string}
     * @memberof SearchDto
     */
    availabilityEnds?: string;
    /**
     * User associations
     * @type {Array<string>}
     * @memberof SearchDto
     */
    associations?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum SearchDtoTripTypesEnum {
    OFFER,
    SEARCH
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoReoccurDaysEnum {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoSmokingEnum {
    YES,
    NO,
    ASK,
    IRRELEVANT
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoAnimalsEnum {
    YES,
    NO,
    ASK,
    IRRELEVANT
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoTransportTypesEnum {
    CAR,
    PLANE,
    BOAT,
    TRAIN
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoBaggageEnum {
    SMALL,
    MEDIUM,
    LARGE,
    HUGE
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoGenderEnum {
    MAN,
    WOMAN,
    IRRELEVANT
}
/**
    * @export
    * @enum {string}
    */
export enum SearchDtoOrganizationsEnum {
    ADAC,
    ACA,
    ACL,
    TCS,
    TOURING
}

/**
 * represents a circular area
 * @export
 * @interface SearchRadius
 */
export interface SearchRadius {
    /**
     * 
     * @type {GeoLocation}
     * @memberof SearchRadius
     */
    location?: GeoLocation;
    /**
     * area radius in kms
     * @type {number}
     * @memberof SearchRadius
     */
    radius?: number;
}
/**
 * represents a time range
 * @export
 * @interface TimeRangeDto
 */
export interface TimeRangeDto {
    /**
     * mean of the time range
     * @type {string}
     * @memberof TimeRangeDto
     */
    time?: string;
    /**
     * duration between the mean and the ends of the time range
     * @type {number}
     * @memberof TimeRangeDto
     */
    toleranceInDays?: number;
}
/**
 * represents transport information of a trip
 * @export
 * @interface TransportDto
 */
export interface TransportDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof TransportDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof TransportDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof TransportDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof TransportDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof TransportDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof TransportDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof TransportDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof TransportDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof TransportDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof TransportDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof TransportDto
     */
    description?: string;
    /**
     * type of vehicle
     * @type {string}
     * @memberof TransportDto
     */
    transportType?: TransportDtoTransportTypeEnum;
    /**
     * maximum number of seats (including driver)
     * @type {number}
     * @memberof TransportDto
     */
    seatingCapacity?: number;
    /**
     * how many baggage can be transported
     * @type {string}
     * @memberof TransportDto
     */
    cargoVolume?: TransportDtoCargoVolumeEnum;
    /**
     * 
     * @type {PersonaDto}
     * @memberof TransportDto
     */
    owner?: PersonaDto;
    /**
     * 
     * @type {PersonaDto}
     * @memberof TransportDto
     */
    operator?: PersonaDto;
    /**
     * color of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    color?: string;
    /**
     * manufacturer of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    manufacturer?: string;
    /**
     * model of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    model?: string;
    /**
     * release date of the vehicle model (things like \"fall 2019\" are valid)
     * @type {string}
     * @memberof TransportDto
     */
    modelDate?: string;
    /**
     * registration ID of the vehicle
     * @type {string}
     * @memberof TransportDto
     */
    registrationId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TransportDtoTransportTypeEnum {
    CAR,
    PLANE,
    BOAT,
    TRAIN
}
/**
    * @export
    * @enum {string}
    */
export enum TransportDtoCargoVolumeEnum {
    SMALL,
    MEDIUM,
    LARGE,
    HUGE
}

/**
 * represents a trip
 * @export
 * @interface TripDto
 */
export interface TripDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof TripDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof TripDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof TripDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof TripDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof TripDto
     */
    modifiedBy?: string;
    /**
     * ID of this object
     * @type {string}
     * @memberof TripDto
     */
    id?: string;
    /**
     * URL of this object
     * @type {string}
     * @memberof TripDto
     */
    url?: string;
    /**
     * additional type information
     * @type {string}
     * @memberof TripDto
     */
    additionalType?: string;
    /**
     * name of this object
     * @type {string}
     * @memberof TripDto
     */
    name?: string;
    /**
     * an image of this object
     * @type {string}
     * @memberof TripDto
     */
    image?: string;
    /**
     * description of this object
     * @type {string}
     * @memberof TripDto
     */
    description?: string;
    /**
     * departure time of the trip
     * @type {string}
     * @memberof TripDto
     */
    departureTime?: string;
    /**
     * arrival time of the trip
     * @type {string}
     * @memberof TripDto
     */
    arrivalTime?: string;
    /**
     * 
     * @type {TransportDto}
     * @memberof TripDto
     */
    transport?: TransportDto;
    /**
     * participants
     * @type {Array<ParticipationDto>}
     * @memberof TripDto
     */
    participations?: Array<ParticipationDto>;
    /**
     * the seats currently available to this trip. at most Transport.seatingCapacity -1 (driver)
     * @type {number}
     * @memberof TripDto
     */
    availableSeats?: number;
    /**
     * 
     * @type {OfferDto}
     * @memberof TripDto
     */
    offer?: OfferDto;
    /**
     * 
     * @type {DemandDto}
     * @memberof TripDto
     */
    demand?: DemandDto;
    /**
     * smoking preferences of the trip
     * @type {string}
     * @memberof TripDto
     */
    smoking?: TripDtoSmokingEnum;
    /**
     * animal transport preferences of the trip
     * @type {string}
     * @memberof TripDto
     */
    animals?: TripDtoAnimalsEnum;
    /**
     * 
     * @type {Array<ScheduleDto>}
     * @memberof TripDto
     */
    schedules?: Array<ScheduleDto>;
    /**
     * itinerary of departure Stops of Trip
     * @type {Array<WeightedPlaceItemDto>}
     * @memberof TripDto
     */
    itinerary?: Array<WeightedPlaceItemDto>;
    /**
     * Subtrips of the trip
     * @type {Array<WeightedTripItemDto>}
     * @memberof TripDto
     */
    subTrips?: Array<WeightedTripItemDto>;
    /**
     * 
     * @type {PlaceDto}
     * @memberof TripDto
     */
    departureFrom?: PlaceDto;
    /**
     * 
     * @type {PlaceDto}
     * @memberof TripDto
     */
    arrivalAt?: PlaceDto;
}

/**
    * @export
    * @enum {string}
    */
export enum TripDtoSmokingEnum {
    YES,
    NO,
    FLEX
}
/**
    * @export
    * @enum {string}
    */
export enum TripDtoAnimalsEnum {
    YES,
    NO,
    ASK
}

/**
 * searching criteria, including pagination options
 * @export
 * @interface UserSearch
 */
export interface UserSearch {
    /**
     * 
     * @type {PageRequest}
     * @memberof UserSearch
     */
    page?: PageRequest;
    /**
     * 
     * @type {SearchRadius}
     * @memberof UserSearch
     */
    location?: SearchRadius;
    /**
     * 
     * @type {IntegerRange}
     * @memberof UserSearch
     */
    age?: IntegerRange;
    /**
     * gender of the persona
     * @type {string}
     * @memberof UserSearch
     */
    gender?: UserSearchGenderEnum;
    /**
     * whether the persona should be single
     * @type {string}
     * @memberof UserSearch
     */
    isSingle?: UserSearchIsSingleEnum;
    /**
     * whether the persona should have an avatar picture
     * @type {string}
     * @memberof UserSearch
     */
    hasAvatar?: UserSearchHasAvatarEnum;
    /**
     * whether the persona should be online
     * @type {string}
     * @memberof UserSearch
     */
    isOnline?: UserSearchIsOnlineEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserSearchGenderEnum {
    MAN,
    WOMAN,
    IRRELEVANT
}
/**
    * @export
    * @enum {string}
    */
export enum UserSearchIsSingleEnum {
    YES,
    NO,
    IRRELEVANT
}
/**
    * @export
    * @enum {string}
    */
export enum UserSearchHasAvatarEnum {
    YES,
    NO,
    IRRELEVANT
}
/**
    * @export
    * @enum {string}
    */
export enum UserSearchIsOnlineEnum {
    YES,
    NO,
    IRRELEVANT
}

/**
 * itinerary of departure Stops of Trip
 * @export
 * @interface WeightedPlaceItemDto
 */
export interface WeightedPlaceItemDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof WeightedPlaceItemDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof WeightedPlaceItemDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof WeightedPlaceItemDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof WeightedPlaceItemDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof WeightedPlaceItemDto
     */
    modifiedBy?: string;
    /**
     * 
     * @type {PlaceDto}
     * @memberof WeightedPlaceItemDto
     */
    item?: PlaceDto;
    /**
     * the weight or order of this Place
     * @type {number}
     * @memberof WeightedPlaceItemDto
     */
    weight?: number;
}
/**
 * Subtrips of the trip
 * @export
 * @interface WeightedTripItemDto
 */
export interface WeightedTripItemDto {
    /**
     * creation time of this object
     * @type {string}
     * @memberof WeightedTripItemDto
     */
    created?: string;
    /**
     * last modification time of this object
     * @type {string}
     * @memberof WeightedTripItemDto
     */
    modified?: string;
    /**
     * a flag, whether this object is deleted
     * @type {boolean}
     * @memberof WeightedTripItemDto
     */
    deleted?: boolean;
    /**
     * id of creator
     * @type {string}
     * @memberof WeightedTripItemDto
     */
    createdBy?: string;
    /**
     * id of modifier
     * @type {string}
     * @memberof WeightedTripItemDto
     */
    modifiedBy?: string;
    /**
     * 
     * @type {TripDto}
     * @memberof WeightedTripItemDto
     */
    item?: TripDto;
    /**
     * the weight or order of this Trip
     * @type {number}
     * @memberof WeightedTripItemDto
     */
    weight?: number;
}

/**
 * DemandsApi - axios parameter creator
 * @export
 */
export const DemandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(demandDto: DemandDto, options: any = {}): RequestArgs {
            // verify required parameter 'demandDto' is not null or undefined
            if (demandDto === null || demandDto === undefined) {
                throw new RequiredError('demandDto','Required parameter demandDto was null or undefined when calling _delete.');
            }
            const localVarPath = `/demand/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof demandDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(demandDto !== undefined ? demandDto : {}) : (demandDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Deman
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(demandDto: DemandDto, options: any = {}): RequestArgs {
            // verify required parameter 'demandDto' is not null or undefined
            if (demandDto === null || demandDto === undefined) {
                throw new RequiredError('demandDto','Required parameter demandDto was null or undefined when calling create.');
            }
            const localVarPath = `/demand/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof demandDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(demandDto !== undefined ? demandDto : {}) : (demandDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteById.');
            }
            const localVarPath = `/demand/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById2.');
            }
            const localVarPath = `/demand/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Demand searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(searchDto: SearchDto, options: any = {}): RequestArgs {
            // verify required parameter 'searchDto' is not null or undefined
            if (searchDto === null || searchDto === undefined) {
                throw new RequiredError('searchDto','Required parameter searchDto was null or undefined when calling search2.');
            }
            const localVarPath = `/demand/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof searchDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(searchDto !== undefined ? searchDto : {}) : (searchDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(demandDto: DemandDto, options: any = {}): RequestArgs {
            // verify required parameter 'demandDto' is not null or undefined
            if (demandDto === null || demandDto === undefined) {
                throw new RequiredError('demandDto','Required parameter demandDto was null or undefined when calling update.');
            }
            const localVarPath = `/demand/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof demandDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(demandDto !== undefined ? demandDto : {}) : (demandDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemandsApi - functional programming interface
 * @export
 */
export const DemandsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(demandDto: DemandDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration)._delete(demandDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create an Deman
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(demandDto: DemandDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).create(demandDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).deleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).getById2(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Demand searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(searchDto: SearchDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).search2(searchDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(demandDto: DemandDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemandDto> {
            const localVarAxiosArgs = DemandsApiAxiosParamCreator(configuration).update(demandDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DemandsApi - factory interface
 * @export
 */
export const DemandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(demandDto: DemandDto, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration)._delete(demandDto, options)(axios, basePath);
        },
        /**
         * Create an Deman
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(demandDto: DemandDto, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).create(demandDto, options)(axios, basePath);
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).deleteById(id, options)(axios, basePath);
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).getById2(id, options)(axios, basePath);
        },
        /**
         * Demand searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(searchDto: SearchDto, options?: any): AxiosPromise<PageDemandDto> {
            return DemandsApiFp(configuration).search2(searchDto, options)(axios, basePath);
        },
        /**
         * Update an Offer
         * @param {DemandDto} demandDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(demandDto: DemandDto, options?: any): AxiosPromise<DemandDto> {
            return DemandsApiFp(configuration).update(demandDto, options)(axios, basePath);
        },
    };
};

/**
 * DemandsApi - object-oriented interface
 * @export
 * @class DemandsApi
 * @extends {BaseAPI}
 */
export class DemandsApi extends BaseAPI {
    /**
     * Delete an Offer
     * @param {DemandDto} demandDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public _delete(demandDto: DemandDto, options?: any) {
        return DemandsApiFp(this.configuration)._delete(demandDto, options)(this.axios, this.basePath);
    }

    /**
     * Create an Deman
     * @param {DemandDto} demandDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public create(demandDto: DemandDto, options?: any) {
        return DemandsApiFp(this.configuration).create(demandDto, options)(this.axios, this.basePath);
    }

    /**
     * Returns the demand with the given ID
     * @param {string} id ID of the demand to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public deleteById(id: string, options?: any) {
        return DemandsApiFp(this.configuration).deleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the demand with the given ID
     * @param {string} id ID of the demand to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public getById2(id: string, options?: any) {
        return DemandsApiFp(this.configuration).getById2(id, options)(this.axios, this.basePath);
    }

    /**
     * Demand searching
     * @param {SearchDto} searchDto Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public search2(searchDto: SearchDto, options?: any) {
        return DemandsApiFp(this.configuration).search2(searchDto, options)(this.axios, this.basePath);
    }

    /**
     * Update an Offer
     * @param {DemandDto} demandDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemandsApi
     */
    public update(demandDto: DemandDto, options?: any) {
        return DemandsApiFp(this.configuration).update(demandDto, options)(this.axios, this.basePath);
    }

}


/**
 * OffersApi - axios parameter creator
 * @export
 */
export const OffersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(offerDto: OfferDto, options: any = {}): RequestArgs {
            // verify required parameter 'offerDto' is not null or undefined
            if (offerDto === null || offerDto === undefined) {
                throw new RequiredError('offerDto','Required parameter offerDto was null or undefined when calling create2.');
            }
            const localVarPath = `/offer/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof offerDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(offerDto !== undefined ? offerDto : {}) : (offerDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(offerDto: OfferDto, options: any = {}): RequestArgs {
            // verify required parameter 'offerDto' is not null or undefined
            if (offerDto === null || offerDto === undefined) {
                throw new RequiredError('offerDto','Required parameter offerDto was null or undefined when calling delete2.');
            }
            const localVarPath = `/offer/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof offerDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(offerDto !== undefined ? offerDto : {}) : (offerDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById1(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteById1.');
            }
            const localVarPath = `/offer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the offer with the given ID
         * @param {string} id ID of the offer to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById4.');
            }
            const localVarPath = `/offer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Offer searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search4(searchDto: SearchDto, options: any = {}): RequestArgs {
            // verify required parameter 'searchDto' is not null or undefined
            if (searchDto === null || searchDto === undefined) {
                throw new RequiredError('searchDto','Required parameter searchDto was null or undefined when calling search4.');
            }
            const localVarPath = `/offer/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof searchDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(searchDto !== undefined ? searchDto : {}) : (searchDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(offerDto: OfferDto, options: any = {}): RequestArgs {
            // verify required parameter 'offerDto' is not null or undefined
            if (offerDto === null || offerDto === undefined) {
                throw new RequiredError('offerDto','Required parameter offerDto was null or undefined when calling update2.');
            }
            const localVarPath = `/offer/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof offerDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(offerDto !== undefined ? offerDto : {}) : (offerDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OffersApi - functional programming interface
 * @export
 */
export const OffersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(offerDto: OfferDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).create2(offerDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(offerDto: OfferDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).delete2(offerDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById1(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).deleteById1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the offer with the given ID
         * @param {string} id ID of the offer to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).getById4(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Offer searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search4(searchDto: SearchDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).search4(searchDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(offerDto: OfferDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDto> {
            const localVarAxiosArgs = OffersApiAxiosParamCreator(configuration).update2(offerDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OffersApi - factory interface
 * @export
 */
export const OffersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(offerDto: OfferDto, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).create2(offerDto, options)(axios, basePath);
        },
        /**
         * Delete an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(offerDto: OfferDto, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).delete2(offerDto, options)(axios, basePath);
        },
        /**
         * Returns the demand with the given ID
         * @param {string} id ID of the demand to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById1(id: string, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).deleteById1(id, options)(axios, basePath);
        },
        /**
         * Returns the offer with the given ID
         * @param {string} id ID of the offer to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4(id: string, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).getById4(id, options)(axios, basePath);
        },
        /**
         * Offer searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search4(searchDto: SearchDto, options?: any): AxiosPromise<PageOfferDto> {
            return OffersApiFp(configuration).search4(searchDto, options)(axios, basePath);
        },
        /**
         * Update an Offer
         * @param {OfferDto} offerDto Offer Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(offerDto: OfferDto, options?: any): AxiosPromise<OfferDto> {
            return OffersApiFp(configuration).update2(offerDto, options)(axios, basePath);
        },
    };
};

/**
 * OffersApi - object-oriented interface
 * @export
 * @class OffersApi
 * @extends {BaseAPI}
 */
export class OffersApi extends BaseAPI {
    /**
     * Create an Offer
     * @param {OfferDto} offerDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public create2(offerDto: OfferDto, options?: any) {
        return OffersApiFp(this.configuration).create2(offerDto, options)(this.axios, this.basePath);
    }

    /**
     * Delete an Offer
     * @param {OfferDto} offerDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public delete2(offerDto: OfferDto, options?: any) {
        return OffersApiFp(this.configuration).delete2(offerDto, options)(this.axios, this.basePath);
    }

    /**
     * Returns the demand with the given ID
     * @param {string} id ID of the demand to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public deleteById1(id: string, options?: any) {
        return OffersApiFp(this.configuration).deleteById1(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the offer with the given ID
     * @param {string} id ID of the offer to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public getById4(id: string, options?: any) {
        return OffersApiFp(this.configuration).getById4(id, options)(this.axios, this.basePath);
    }

    /**
     * Offer searching
     * @param {SearchDto} searchDto Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public search4(searchDto: SearchDto, options?: any) {
        return OffersApiFp(this.configuration).search4(searchDto, options)(this.axios, this.basePath);
    }

    /**
     * Update an Offer
     * @param {OfferDto} offerDto Offer Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public update2(offerDto: OfferDto, options?: any) {
        return OffersApiFp(this.configuration).update2(offerDto, options)(this.axios, this.basePath);
    }

}


/**
 * PersonasApi - axios parameter creator
 * @export
 */
export const PersonasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById3.');
            }
            const localVarPath = `/persona/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the contact infos of the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactPoints1(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactPoints1.');
            }
            const localVarPath = `/persona/{id}/contact`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persona searching
         * @param {UserSearch} userSearch Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(userSearch: UserSearch, options: any = {}): RequestArgs {
            // verify required parameter 'userSearch' is not null or undefined
            if (userSearch === null || userSearch === undefined) {
                throw new RequiredError('userSearch','Required parameter userSearch was null or undefined when calling search3.');
            }
            const localVarPath = `/persona/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userSearch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userSearch !== undefined ? userSearch : {}) : (userSearch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonasApi - functional programming interface
 * @export
 */
export const PersonasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PersonasApiAxiosParamCreator(configuration).getById3(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the contact infos of the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactPoints1(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PersonasApiAxiosParamCreator(configuration).getContactPoints1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Persona searching
         * @param {UserSearch} userSearch Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(userSearch: UserSearch, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PersonasApiAxiosParamCreator(configuration).search3(userSearch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonasApi - factory interface
 * @export
 */
export const PersonasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options?: any): AxiosPromise<void> {
            return PersonasApiFp(configuration).getById3(id, options)(axios, basePath);
        },
        /**
         * Returns the contact infos of the persona with the given ID
         * @param {string} id ID of the persona to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactPoints1(id: string, options?: any): AxiosPromise<void> {
            return PersonasApiFp(configuration).getContactPoints1(id, options)(axios, basePath);
        },
        /**
         * Persona searching
         * @param {UserSearch} userSearch Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(userSearch: UserSearch, options?: any): AxiosPromise<void> {
            return PersonasApiFp(configuration).search3(userSearch, options)(axios, basePath);
        },
    };
};

/**
 * PersonasApi - object-oriented interface
 * @export
 * @class PersonasApi
 * @extends {BaseAPI}
 */
export class PersonasApi extends BaseAPI {
    /**
     * Returns the persona with the given ID
     * @param {string} id ID of the persona to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getById3(id: string, options?: any) {
        return PersonasApiFp(this.configuration).getById3(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the contact infos of the persona with the given ID
     * @param {string} id ID of the persona to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getContactPoints1(id: string, options?: any) {
        return PersonasApiFp(this.configuration).getContactPoints1(id, options)(this.axios, this.basePath);
    }

    /**
     * Persona searching
     * @param {UserSearch} userSearch Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public search3(userSearch: UserSearch, options?: any) {
        return PersonasApiFp(this.configuration).search3(userSearch, options)(this.axios, this.basePath);
    }

}


/**
 * TripsApi - axios parameter creator
 * @export
 */
export const TripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the trip with the given ID
         * @param {string} id ID of the trip to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById1.');
            }
            const localVarPath = `/trip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trip searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchDto: SearchDto, options: any = {}): RequestArgs {
            // verify required parameter 'searchDto' is not null or undefined
            if (searchDto === null || searchDto === undefined) {
                throw new RequiredError('searchDto','Required parameter searchDto was null or undefined when calling search1.');
            }
            const localVarPath = `/trip/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof searchDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(searchDto !== undefined ? searchDto : {}) : (searchDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Minimal trip searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMinimal1(searchDto: SearchDto, options: any = {}): RequestArgs {
            // verify required parameter 'searchDto' is not null or undefined
            if (searchDto === null || searchDto === undefined) {
                throw new RequiredError('searchDto','Required parameter searchDto was null or undefined when calling searchMinimal1.');
            }
            const localVarPath = `/trip/search/minimal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof searchDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(searchDto !== undefined ? searchDto : {}) : (searchDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TripsApi - functional programming interface
 * @export
 */
export const TripsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the trip with the given ID
         * @param {string} id ID of the trip to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripDto> {
            const localVarAxiosArgs = TripsApiAxiosParamCreator(configuration).getById1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trip searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchDto: SearchDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageTripDto> {
            const localVarAxiosArgs = TripsApiAxiosParamCreator(configuration).search1(searchDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Minimal trip searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMinimal1(searchDto: SearchDto, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TripsApiAxiosParamCreator(configuration).searchMinimal1(searchDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TripsApi - factory interface
 * @export
 */
export const TripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the trip with the given ID
         * @param {string} id ID of the trip to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options?: any): AxiosPromise<TripDto> {
            return TripsApiFp(configuration).getById1(id, options)(axios, basePath);
        },
        /**
         * Trip searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchDto: SearchDto, options?: any): AxiosPromise<PageTripDto> {
            return TripsApiFp(configuration).search1(searchDto, options)(axios, basePath);
        },
        /**
         * Minimal trip searching
         * @param {SearchDto} searchDto Search criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMinimal1(searchDto: SearchDto, options?: any): AxiosPromise<void> {
            return TripsApiFp(configuration).searchMinimal1(searchDto, options)(axios, basePath);
        },
    };
};

/**
 * TripsApi - object-oriented interface
 * @export
 * @class TripsApi
 * @extends {BaseAPI}
 */
export class TripsApi extends BaseAPI {
    /**
     * Returns the trip with the given ID
     * @param {string} id ID of the trip to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public getById1(id: string, options?: any) {
        return TripsApiFp(this.configuration).getById1(id, options)(this.axios, this.basePath);
    }

    /**
     * Trip searching
     * @param {SearchDto} searchDto Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public search1(searchDto: SearchDto, options?: any) {
        return TripsApiFp(this.configuration).search1(searchDto, options)(this.axios, this.basePath);
    }

    /**
     * Minimal trip searching
     * @param {SearchDto} searchDto Search criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public searchMinimal1(searchDto: SearchDto, options?: any) {
        return TripsApiFp(this.configuration).searchMinimal1(searchDto, options)(this.axios, this.basePath);
    }

}


